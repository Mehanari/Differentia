using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Src.Math.CirclesArt
{
    /// <summary>
    /// Each dot of a drawing generated by each specimen has some error represented by an error vector.
    /// Some of these errors a bigger, some are smaller.
    /// We can take a look at errors of each point for an entire population and determine which
    /// points tend to have the biggest errors.
    /// For points with bigger errors we should pay more attention, that is, give them more weight.
    ///
    /// This algorithm also implements its own elitism mechanism.
    /// </summary>
    public class AttentionDistributionGA : BaseGA
    {

        
        public float ElitismPercent = 0.01f;
        
        //Relative weights for reach point of a target drawing.
        private float[] _currentAttentionDistribution;
        
        private float[] _currentMinErrorModules;
        private float[] _currentMaxErrorModules;

        //Precision is a value in range from 0 to 1. 0 means that for that particular
        //point a specimen has the biggest error in the population, 1 means that specimen has the least
        //error in the current population.
        private Dictionary<Specimen, float[]> _currentPopulationPrecisions;
        
        public override Circle[] Fit(Circle[] initialState, float timeStep, int samplesCount, (int index, Vector3 point)[] keyPoints)
        {
            _currentPopulationPrecisions = new();
            _currentMaxErrorModules = new float[keyPoints.Length];
            _currentMinErrorModules = new float[keyPoints.Length];
            _currentAttentionDistribution = new float[keyPoints.Length];
            for (int i = 0; i < _currentAttentionDistribution.Length; i++)
            {
                _currentAttentionDistribution[i] = 1f / _currentAttentionDistribution.Length;
            }
            return base.Fit(initialState, timeStep, samplesCount, keyPoints);
        }

        protected override void SortPopulation(Specimen[] population)
        {
            CalculateMinAndMaxErrorModules(population);
            CalculatePrecisions(population);
            CalculatePopulationAppeals(population);
            RedistributeAttention(population);
            var comparer = new AppealSpecimenComparer();
            Array.Sort(population, comparer);
        }

        private void RedistributeAttention(Specimen[] population)
        {
            var averageErrorModules = CalculateAverageErrorModules(population);
            var normalizedErrorModules = CalculusUtils.NormalizeVector(averageErrorModules);
            Debug.Log("Normalized vector sum: " + normalizedErrorModules.Sum());
            _currentAttentionDistribution = normalizedErrorModules;
        }

        /// <summary>
        /// Calculating average error module for every point.
        /// Points with the biggest average error should have more attention.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        private float[] CalculateAverageErrorModules(Specimen[] population)
        {
            var averageErrorModules = new float[CurrentFitKeyPoints.Length];
            for (int i = 0; i < averageErrorModules.Length; i++)
            {
                var sum = 0f;
                foreach (var specimen in population)
                {
                    sum += specimen.ErrorsModules[i];
                }

                averageErrorModules[i] = sum / population.Length;
            }

            return averageErrorModules;
        }

        protected override void GenerateNewPopulation(Specimen[] newPopulation, Specimen[] previousPopulation)
        {
            var eliteMaxIndex = (int) (previousPopulation.Length * ElitismPercent);
            var previousPopulationCopy = new Specimen[previousPopulation.Length];
            Array.Copy(previousPopulation, previousPopulationCopy, previousPopulationCopy.Length);
            Array.Sort(previousPopulationCopy, new MaxErrorComparer());
            for (int i = 0; i <= eliteMaxIndex; i++)
            {
                newPopulation[i] = previousPopulationCopy[i];
            }
            for (int i = eliteMaxIndex+1; i < newPopulation.Length; i++)
            {
                var parentAIndex = PickIndexPoison(previousPopulation.Length);
                var parentBIndex = PickIndexPoison(previousPopulation.Length, lambda: 0.5f, parentAIndex);
                var child = Breed(previousPopulation[parentAIndex], previousPopulation[parentBIndex]);
                Mutate(child);
                newPopulation[i] = child;
            }
        }

        private void CalculateMinAndMaxErrorModules(Specimen[] population)
        {
            for (int i = 0; i < CurrentFitKeyPoints.Length; i++)
            {
                var minErrorModule = float.MaxValue;
                var maxErrorModule = float.MinValue;
                foreach (var specimen in population)
                {
                    var errorModule = specimen.ErrorsModules[i];
                    if (errorModule < minErrorModule)
                    {
                        minErrorModule = errorModule;
                    }

                    if (errorModule > maxErrorModule)
                    {
                        maxErrorModule = errorModule;
                    }
                }

                _currentMaxErrorModules[i] = maxErrorModule;
                _currentMinErrorModules[i] = minErrorModule;
            }
        }

        private void CalculatePrecisions(Specimen[] population)
        {
            _currentPopulationPrecisions.Clear();
            foreach (var specimen in population)        
            {
                _currentPopulationPrecisions.Add(specimen, new float[specimen.ErrorsModules.Length]);
                for (int i = 0; i < specimen.ErrorsModules.Length; i++)
                {
                    var error = specimen.ErrorsModules[i];
                    var best = _currentMinErrorModules[i];
                    var worst = _currentMaxErrorModules[i];
                    var precision = (error - worst) / (best - worst);
                    _currentPopulationPrecisions[specimen][i] = precision;
                }
            }
        }

        protected override void CalculatePopulationAppeals(Specimen[] population)
        {
            foreach (var specimen in population)
            {
                CalculateAppealAsWeightedPrecisionsSum(specimen);
            }
        }

        private void CalculateAppealAsWeightedPrecisionsSum(Specimen specimen)
        {
            var sum = 0f;
            var precisions = _currentPopulationPrecisions[specimen];
            for (int i = 0; i < precisions.Length; i++)
            {
                var weight = _currentAttentionDistribution[i];
                sum += precisions[i] * weight;
            }

            specimen.Appeal = sum;
        }
    }
}